#!/usr/bin/env bash
set -e

## Bash script to run after a successful renewal of Let's Encrypt certificate
## Put it in /etc/letsencrypt/renewal-hooks/deploy and it will be executed
## by certbot upon a successful renewal

cloud_provider=_CLOUD_PROVIDER_
upload_certificate_manager=_UPLOAD_CERTIFICATE_MANAGER_
certificate_arn=_CERTIFICATE_ARN_

_log(){
    now=$(date)
    echo "$now - $1 - $2"
}

_log_info(){
    _log "INFO" "$1"
}

_log_warn(){
    _log "WARN" "$1"
}

_log_error(){
    _log "ERROR" "$1"
}

BASE=/etc/letsencrypt/live
# There should only be one domain name
for domain in $BASE/*; do
    if [ -d $domain ] && [[ $domain =~ .*\.hopsworks\..* ]]; then
        working_dir=$domain
        working_domain=$(basename $domain)
    fi
done    

[[ -d $working_dir ]] || exit 2

_log_info "Let's encrypt directory: $working_dir"

_deploy_certificate_local(){
    # important
    set +e
    KEYSTOREPW=<%= node['hopsworks']['master']['password'] %>
    GF_DOMAIN_NAME=<%= node['hopsworks']['domain_name'] %>
    GF_DOMAIN=<%= node['hopsworks']['domains_dir'] %>/$GF_DOMAIN_NAME
    GF_USER=<%= node['hopsworks']['user'] %>
    GF_GROUP=<%= node['hopsworks']['group'] %>
    SPARK_CONF_DIR=<%= node['hadoop_spark']['conf_dir'] %>
    
    TMP="/root/letsencrypt/tmp"
    mkdir -p $TMP

    DATE=$(date +%Y-%m-%d)
    BACKUP_DIR="/root/letsencrypt/backup/$DATE"
    mkdir -p $BACKUP_DIR

    cp -f "$GF_DOMAIN/config/keystore.jks" $BACKUP_DIR
    cp -f "$GF_DOMAIN/config/cacerts.jks" $BACKUP_DIR

    cp -f "$GF_DOMAIN/config/keystore.jks" $TMP
    cp -f "$GF_DOMAIN/config/cacerts.jks" $TMP

    pushd $TMP
    # Bundle private key and certificate
    openssl pkcs12 -export -in ${working_dir}/cert.pem -inkey ${working_dir}/privkey.pem -out cert_and_key.p12 -name ${working_domain} -CAfile ${working_dir}/chain.pem -caname root -password pass:$KEYSTOREPW
    # Remove existing/old certificate for the domain
    keytool -delete -keystore keystore.jks -alias ${working_domain} -srcstorepass $KEYSTOREPW -deststorepass $KEYSTOREPW -destkeypass $KEYSTOREPW
    # Import new private key and certificate bundle
    keytool -importkeystore -destkeystore keystore.jks -srckeystore cert_and_key.p12 -srcstoretype PKCS12 -alias ${working_domain} -srcstorepass $KEYSTOREPW -deststorepass $KEYSTOREPW -destkeypass $KEYSTOREPW
    # Remove old root certificate from trust anchor
    keytool -delete -keystore keystore.jks -alias root -srcstorepass $KEYSTOREPW -deststorepass $KEYSTOREPW -destkeypass $KEYSTOREPW
    # Add new root certificate as trust anchor
    keytool -import -noprompt -trustcacerts -alias root -file ${working_dir}/chain.pem -keystore keystore.jks -srcstorepass $KEYSTOREPW -deststorepass $KEYSTOREPW -destkeypass $KEYSTOREPW

    # Bundle for glassfish-instance
    openssl pkcs12 -export -in ${working_dir}/fullchain.pem -inkey ${working_dir}/privkey.pem -out pkcs.p12 -name glassfish-instance -password pass:$KEYSTOREPW
    keytool -delete -keystore keystore.jks -alias glassfish-instance -srcstorepass $KEYSTOREPW -deststorepass $KEYSTOREPW -destkeypass $KEYSTOREPW
    keytool -importkeystore -destkeystore keystore.jks -srckeystore pkcs.p12 -srcstoretype PKCS12 -alias glassfish-instance -srcstorepass $KEYSTOREPW -deststorepass $KEYSTOREPW -destkeypass $KEYSTOREPW
    openssl pkcs12 -export -in ${working_dir}/fullchain.pem -inkey ${working_dir}/privkey.pem -out pkcs.p12 -name s1as -password pass:$KEYSTOREPW
    keytool -delete -keystore keystore.jks -alias s1as -srcstorepass $KEYSTOREPW -deststorepass $KEYSTOREPW -destkeypass $KEYSTOREPW
    keytool -importkeystore -destkeystore keystore.jks -srckeystore pkcs.p12 -srcstoretype PKCS12 -alias s1as -srcstorepass $KEYSTOREPW -deststorepass $KEYSTOREPW -destkeypass $KEYSTOREPW

    keytool -export -alias glassfish-instance -file glassfish-instance.cert -keystore keystore.jks -storepass $KEYSTOREPW
    keytool -export -alias s1as -file s1as.cert -keystore keystore.jks -storepass $KEYSTOREPW

    # Update Glassfish CA certs
    keytool -delete -keystore cacerts.jks -alias s1as -storepass $KEYSTOREPW
    keytool -import -noprompt -alias s1as -file s1as.cert -keystore cacerts.jks -storepass $KEYSTOREPW
    keytool -delete -keystore cacerts.jks -alias glassfish-instance -storepass $KEYSTOREPW
    keytool -import -noprompt -alias glassfish-instance -file glassfish-instance.cert -keystore cacerts.jks -storepass $KEYSTOREPW

    # Convert cacerts to pem format
    keytool -importkeystore -srckeystore cacerts.jks -destkeystore cacerts.p12 -srcstoretype jks -deststoretype pkcs12 -noprompt -srcstorepass $KEYSTOREPW -deststorepass $KEYSTOREPW
    openssl pkcs12 -in cacerts.p12 -out cacerts.pem -passin pass:$KEYSTOREPW

    cp -f cacerts.jks ${SPARK_CONF_DIR}/cacerts.jks
    mv -f cacerts.pem ${SPARK_CONF_DIR}/cacerts.pem
    mv -f keystore.jks ${GF_DOMAIN}/config/keystore.jks
    mv -f cacerts.jks ${GF_DOMAIN}/config/cacerts.jks

    rm -f cacerts.p12

    pushd ${GF_DOMAIN}/config
    chown ${GF_USER}:${GF_GROUP} keystore.jks
    chmod 600 keystore.jks

    chown ${GF_USER}:${GF_GROUP} cacerts.jks                                                                                                                                                                                          [12/475]
    chmod 655 cacerts.jks

    systemctl restart glassfish-$GF_DOMAIN_NAME
    echo "Restarting glassfish..."
    yes | ${GF_DOMAIN}/bin/domain1_asadmin disable-secure-admin
    yes | ${GF_DOMAIN}/bin/domain1_asadmin enable-secure-admin
}

_deploy_aws_certificate_manager(){
    _log_info "Deploying AWS certificate manager"
    if [ -z "$certificate_arn" ]; then
        _log_error "You have to supply AWS Certificate Manager certificate ARN"
        exit 1
    fi
    aws_region=$(echo $certificate_arn | awk -F ":" '{ print $4}')
    _log_info "AWS: Importing to $certificate_arn - Region: $aws_region"
    aws --region ${aws_region} acm import-certificate \
        --certificate-arn ${certificate_arn} \
        --certificate fileb://${working_dir}/cert.pem \
        --private-key fileb://${working_dir}/privkey.pem
    _log_info "AWS: Successfully deployed Let's Encrypt certificate to Certificate Manager"
}

_deploy_gcp_certificate_manager(){
    _log_info "Deploying GCP certificate manager"
    _log_error "Not implemented yet"
    exit 1
}

_deploy_azure_certificate_manager(){
    _log_info "Deploying Azure certificate manager"
    _log_error "Not implemented yet"
    exit 1
}

if [ "$upload_certificate_manager" == "true" ]; then
    _log_info "Cloud provider: $cloud_provider - certificate_arn: $certificate_arn"
    if [ "$cloud_provider" == "aws" ] || [ "$cloud_provider" == "AWS" ]; then
        _deploy_aws_certificate_manager
    elif [ "$cloud_provider" == "gcp" ] || [ "$cloud_provider" == "GCP" ]; then
        _deploy_gcp_certificate_manager
    elif [ "$cloud_provider" == "azure" ] || [ "$cloud_provider" == "AZURE" ]; then
        _deploy_azure_certificate_manager
    fi
else
    _log_info "Deploy certificate locally"
    _deploy_certificate_local
fi
